//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
// @ts-nocheck

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  // Enforce always return empty string as baseUrl
  getBaseUrl(defaultUrl: string, baseUrl: string) {
    return "";
  }

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    if (this.authToken) {
      options.headers["authorization"] = `Bearer ${this.authToken}`;
    }
    return Promise.resolve(options);
  }
}

export class VcmpCommunicationUserClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param communicationUserIds (optional) 
     * @return OK
     */
    getCommunicationUsers(communicationUserIds?: string[] | undefined): Promise<CommunicationUser[]> {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/info?";
        if (communicationUserIds === null)
            throw new Error("The parameter 'communicationUserIds' cannot be null.");
        else if (communicationUserIds !== undefined)
            communicationUserIds && communicationUserIds.forEach(item => { url_ += "communicationUserIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCommunicationUsers(_response);
        });
    }

    protected processGetCommunicationUsers(response: Response): Promise<CommunicationUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommunicationUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunicationUser[]>(null as any);
    }

    /**
     * @return OK
     */
    getOperator(): Promise<CommunicationUser> {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/operator";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOperator(_response);
        });
    }

    protected processGetOperator(response: Response): Promise<CommunicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommunicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunicationUser>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getSeller(body?: GetSellerCommunicationUserQuery | undefined): Promise<CommunicationUser> {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/seller";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSeller(_response);
        });
    }

    protected processGetSeller(response: Response): Promise<CommunicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommunicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunicationUser>(null as any);
    }
}

export class VcmpConversationClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    search(body?: SearchConversationsQuery | undefined): Promise<SearchConversationResult> {
        let url_ = this.baseUrl + "/api/vcmp/conversation/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<SearchConversationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchConversationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchConversationResult>(null as any);
    }

    /**
     * @param conversationId (optional) 
     * @return OK
     */
    getById(conversationId?: string | undefined): Promise<Conversation> {
        let url_ = this.baseUrl + "/api/vcmp/conversation/getbyid?";
        if (conversationId === null)
            throw new Error("The parameter 'conversationId' cannot be null.");
        else if (conversationId !== undefined)
            url_ += "conversationId=" + encodeURIComponent("" + conversationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<Conversation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Conversation.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Conversation>(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param entityType (optional) 
     * @return OK
     */
    getByEntity(entityId?: string | undefined, entityType?: string | undefined): Promise<Conversation> {
        let url_ = this.baseUrl + "/api/vcmp/conversation/getbyentity?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (entityType === null)
            throw new Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByEntity(_response);
        });
    }

    protected processGetByEntity(response: Response): Promise<Conversation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Conversation.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Conversation>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createConversation(body?: SearchConversationsQuery | undefined): Promise<Conversation> {
        let url_ = this.baseUrl + "/api/vcmp/conversation/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateConversation(_response);
        });
    }

    protected processCreateConversation(response: Response): Promise<Conversation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Conversation.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Conversation>(null as any);
    }
}

export class VcmpMessageClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    search(body?: SearchMessagesQuery | undefined): Promise<SearchMessageResult> {
        let url_ = this.baseUrl + "/api/vcmp/message/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<SearchMessageResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchMessageResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchMessageResult>(null as any);
    }

    /**
     * @param threadId (optional) 
     * @return OK
     */
    getThread(threadId?: string | undefined): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/vcmp/message/thread?";
        if (threadId === null)
            throw new Error("The parameter 'threadId' cannot be null.");
        else if (threadId !== undefined)
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetThread(_response);
        });
    }

    protected processGetThread(response: Response): Promise<Message[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Message.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendMessage(body?: SendMessageCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/message/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessage(body?: UpdateMessageCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/message/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMessage(_response);
        });
    }

    protected processUpdateMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteMessage(body?: DeleteMessageCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMessage(_response);
        });
    }

    protected processDeleteMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    markMessageAsRead(body?: MarkMessageAsReadCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/message/markread";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMarkMessageAsRead(_response);
        });
    }

    protected processMarkMessageAsRead(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendReaction(body?: SendReactionCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/message/sendreaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendReaction(_response);
        });
    }

    protected processSendReaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getUnreadMessageCount(body?: GetUnreadCountQuery | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/vcmp/message/unreadcount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUnreadMessageCount(_response);
        });
    }

    protected processGetUnreadMessageCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class CommunicationUser implements ICommunicationUser {
    userName?: string | undefined;
    userId?: string | undefined;
    userType?: string | undefined;
    avatarUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICommunicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.userType = _data["userType"];
            this.avatarUrl = _data["avatarUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommunicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["userType"] = this.userType;
        data["avatarUrl"] = this.avatarUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommunicationUser {
    userName?: string | undefined;
    userId?: string | undefined;
    userType?: string | undefined;
    avatarUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Conversation implements IConversation {
    name?: string | undefined;
    iconUrl?: string | undefined;
    entityId?: string | undefined;
    entityType?: string | undefined;
    lastMessageId?: string | undefined;
    lastMessageTimestamp?: Date;
    users?: ConversationUser[] | undefined;
    unreadMessagesCount?: number;
    lastMessage?: Message | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IConversation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.lastMessageId = _data["lastMessageId"];
            this.lastMessageTimestamp = _data["lastMessageTimestamp"] ? new Date(_data["lastMessageTimestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(ConversationUser.fromJS(item));
            }
            this.unreadMessagesCount = _data["unreadMessagesCount"];
            this.lastMessage = _data["lastMessage"] ? Message.fromJS(_data["lastMessage"]) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Conversation {
        data = typeof data === 'object' ? data : {};
        let result = new Conversation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["lastMessageId"] = this.lastMessageId;
        data["lastMessageTimestamp"] = this.lastMessageTimestamp ? this.lastMessageTimestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["unreadMessagesCount"] = this.unreadMessagesCount;
        data["lastMessage"] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IConversation {
    name?: string | undefined;
    iconUrl?: string | undefined;
    entityId?: string | undefined;
    entityType?: string | undefined;
    lastMessageId?: string | undefined;
    lastMessageTimestamp?: Date;
    users?: ConversationUser[] | undefined;
    unreadMessagesCount?: number;
    lastMessage?: Message | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ConversationUser implements IConversationUser {
    conversationId?: string | undefined;
    userId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IConversationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conversationId = _data["conversationId"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConversationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversationId"] = this.conversationId;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IConversationUser {
    conversationId?: string | undefined;
    userId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DeleteMessageCommand implements IDeleteMessageCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageIds!: string[];

    constructor(data?: IDeleteMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.messageIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            if (Array.isArray(_data["messageIds"])) {
                this.messageIds = [] as any;
                for (let item of _data["messageIds"])
                    this.messageIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        if (Array.isArray(this.messageIds)) {
            data["messageIds"] = [];
            for (let item of this.messageIds)
                data["messageIds"].push(item);
        }
        return data;
    }
}

export interface IDeleteMessageCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageIds: string[];
}

export class GetSellerCommunicationUserQuery implements IGetSellerCommunicationUserQuery {
    entityId!: string;
    entityType!: string;

    constructor(data?: IGetSellerCommunicationUserQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): GetSellerCommunicationUserQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSellerCommunicationUserQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        return data;
    }
}

export interface IGetSellerCommunicationUserQuery {
    entityId: string;
    entityType: string;
}

export class GetUnreadCountQuery implements IGetUnreadCountQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    recipientId?: string | undefined;
    entityId!: string;
    entityType!: string;

    constructor(data?: IGetUnreadCountQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.recipientId = _data["recipientId"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): GetUnreadCountQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnreadCountQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["recipientId"] = this.recipientId;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        return data;
    }
}

export interface IGetUnreadCountQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    recipientId?: string | undefined;
    entityId: string;
    entityType: string;
}

export class MarkMessageAsReadCommand implements IMarkMessageAsReadCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageId!: string;
    recipientId?: string | undefined;
    notRead?: boolean;

    constructor(data?: IMarkMessageAsReadCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.messageId = _data["messageId"];
            this.recipientId = _data["recipientId"];
            this.notRead = _data["notRead"];
        }
    }

    static fromJS(data: any): MarkMessageAsReadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkMessageAsReadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["messageId"] = this.messageId;
        data["recipientId"] = this.recipientId;
        data["notRead"] = this.notRead;
        return data;
    }
}

export interface IMarkMessageAsReadCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageId: string;
    recipientId?: string | undefined;
    notRead?: boolean;
}

export class Message implements IMessage {
    senderId?: string | undefined;
    content?: string | undefined;
    threadId?: string | undefined;
    conversationId?: string | undefined;
    attachments?: MessageAttachment[] | undefined;
    recipients?: MessageRecipient[] | undefined;
    reactions?: MessageReaction[] | undefined;
    answers?: Message[] | undefined;
    conversation?: Conversation | undefined;
    readonly answersCount?: number | undefined;
    readonly entityId?: string | undefined;
    readonly entityType?: string | undefined;
    sender?: CommunicationUser | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderId = _data["senderId"];
            this.content = _data["content"];
            this.threadId = _data["threadId"];
            this.conversationId = _data["conversationId"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(MessageAttachment.fromJS(item));
            }
            if (Array.isArray(_data["recipients"])) {
                this.recipients = [] as any;
                for (let item of _data["recipients"])
                    this.recipients!.push(MessageRecipient.fromJS(item));
            }
            if (Array.isArray(_data["reactions"])) {
                this.reactions = [] as any;
                for (let item of _data["reactions"])
                    this.reactions!.push(MessageReaction.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Message.fromJS(item));
            }
            this.conversation = _data["conversation"] ? Conversation.fromJS(_data["conversation"]) : <any>undefined;
            (<any>this).answersCount = _data["answersCount"];
            (<any>this).entityId = _data["entityId"];
            (<any>this).entityType = _data["entityType"];
            this.sender = _data["sender"] ? CommunicationUser.fromJS(_data["sender"]) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderId"] = this.senderId;
        data["content"] = this.content;
        data["threadId"] = this.threadId;
        data["conversationId"] = this.conversationId;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.recipients)) {
            data["recipients"] = [];
            for (let item of this.recipients)
                data["recipients"].push(item.toJSON());
        }
        if (Array.isArray(this.reactions)) {
            data["reactions"] = [];
            for (let item of this.reactions)
                data["reactions"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["conversation"] = this.conversation ? this.conversation.toJSON() : <any>undefined;
        data["answersCount"] = this.answersCount;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessage {
    senderId?: string | undefined;
    content?: string | undefined;
    threadId?: string | undefined;
    conversationId?: string | undefined;
    attachments?: MessageAttachment[] | undefined;
    recipients?: MessageRecipient[] | undefined;
    reactions?: MessageReaction[] | undefined;
    answers?: Message[] | undefined;
    conversation?: Conversation | undefined;
    answersCount?: number | undefined;
    entityId?: string | undefined;
    entityType?: string | undefined;
    sender?: CommunicationUser | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MessageAttachment implements IMessageAttachment {
    messageId?: string | undefined;
    attachmentUrl?: string | undefined;
    fileType?: string | undefined;
    fileSize?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMessageAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.fileType = _data["fileType"];
            this.fileSize = _data["fileSize"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new MessageAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["fileType"] = this.fileType;
        data["fileSize"] = this.fileSize;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageAttachment {
    messageId?: string | undefined;
    attachmentUrl?: string | undefined;
    fileType?: string | undefined;
    fileSize?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MessageReaction implements IMessageReaction {
    messageId?: string | undefined;
    userId?: string | undefined;
    reaction?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMessageReaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.userId = _data["userId"];
            this.reaction = _data["reaction"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageReaction {
        data = typeof data === 'object' ? data : {};
        let result = new MessageReaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["userId"] = this.userId;
        data["reaction"] = this.reaction;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageReaction {
    messageId?: string | undefined;
    userId?: string | undefined;
    reaction?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MessageRecipient implements IMessageRecipient {
    messageId?: string | undefined;
    recipientId?: string | undefined;
    readStatus?: string | undefined;
    readTimestamp?: Date;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMessageRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.recipientId = _data["recipientId"];
            this.readStatus = _data["readStatus"];
            this.readTimestamp = _data["readTimestamp"] ? new Date(_data["readTimestamp"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MessageRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new MessageRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["recipientId"] = this.recipientId;
        data["readStatus"] = this.readStatus;
        data["readTimestamp"] = this.readTimestamp ? this.readTimestamp.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMessageRecipient {
    messageId?: string | undefined;
    recipientId?: string | undefined;
    readStatus?: string | undefined;
    readTimestamp?: Date;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MessageShort implements IMessageShort {
    senderId?: string | undefined;
    recipientId?: string | undefined;
    conversationId?: string | undefined;
    entityId?: string | undefined;
    entityType?: string | undefined;
    content?: string | undefined;
    replyTo?: string | undefined;

    constructor(data?: IMessageShort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderId = _data["senderId"];
            this.recipientId = _data["recipientId"];
            this.conversationId = _data["conversationId"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.content = _data["content"];
            this.replyTo = _data["replyTo"];
        }
    }

    static fromJS(data: any): MessageShort {
        data = typeof data === 'object' ? data : {};
        let result = new MessageShort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderId"] = this.senderId;
        data["recipientId"] = this.recipientId;
        data["conversationId"] = this.conversationId;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["content"] = this.content;
        data["replyTo"] = this.replyTo;
        return data;
    }
}

export interface IMessageShort {
    senderId?: string | undefined;
    recipientId?: string | undefined;
    conversationId?: string | undefined;
    entityId?: string | undefined;
    entityType?: string | undefined;
    content?: string | undefined;
    replyTo?: string | undefined;
}

export class SearchConversationResult implements ISearchConversationResult {
    totalCount?: number;
    results?: Conversation[] | undefined;

    constructor(data?: ISearchConversationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Conversation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchConversationResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchConversationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchConversationResult {
    totalCount?: number;
    results?: Conversation[] | undefined;
}

export class SearchConversationsQuery implements ISearchConversationsQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    userIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchConversationsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchConversationsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchConversationsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchConversationsQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    userIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SearchMessageResult implements ISearchMessageResult {
    totalCount?: number;
    results?: Message[] | undefined;

    constructor(data?: ISearchMessageResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchMessageResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchMessageResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchMessageResult {
    totalCount?: number;
    results?: Message[] | undefined;
}

export class SearchMessagesQuery implements ISearchMessagesQuery {
    entityId?: string | undefined;
    entityType?: string | undefined;
    conversationId?: string | undefined;
    threadId?: string | undefined;
    rootsOnly?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchMessagesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.conversationId = _data["conversationId"];
            this.threadId = _data["threadId"];
            this.rootsOnly = _data["rootsOnly"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchMessagesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchMessagesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["conversationId"] = this.conversationId;
        data["threadId"] = this.threadId;
        data["rootsOnly"] = this.rootsOnly;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchMessagesQuery {
    entityId?: string | undefined;
    entityType?: string | undefined;
    conversationId?: string | undefined;
    threadId?: string | undefined;
    rootsOnly?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SendMessageCommand implements ISendMessageCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    message!: MessageShort;

    constructor(data?: ISendMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.message = new MessageShort();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.message = _data["message"] ? MessageShort.fromJS(_data["message"]) : new MessageShort();
        }
    }

    static fromJS(data: any): SendMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISendMessageCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    message: MessageShort;
}

export class SendReactionCommand implements ISendReactionCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageId!: string;
    reactorId?: string | undefined;
    reaction?: string | undefined;

    constructor(data?: ISendReactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.messageId = _data["messageId"];
            this.reactorId = _data["reactorId"];
            this.reaction = _data["reaction"];
        }
    }

    static fromJS(data: any): SendReactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendReactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["messageId"] = this.messageId;
        data["reactorId"] = this.reactorId;
        data["reaction"] = this.reaction;
        return data;
    }
}

export interface ISendReactionCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageId: string;
    reactorId?: string | undefined;
    reaction?: string | undefined;
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;
}

export class UpdateMessageCommand implements IUpdateMessageCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageId!: string;
    content!: string;

    constructor(data?: IUpdateMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.messageId = _data["messageId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdateMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["messageId"] = this.messageId;
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdateMessageCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    messageId: string;
    content: string;
}

export enum SortInfoSortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable */