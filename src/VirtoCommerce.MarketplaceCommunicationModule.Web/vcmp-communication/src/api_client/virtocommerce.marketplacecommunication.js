//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
// @ts-nocheck
export class AuthApiBase {
    constructor() {
        Object.defineProperty(this, "authToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
    }
    // Enforce always return empty string as baseUrl
    getBaseUrl(defaultUrl, baseUrl) {
        return "";
    }
    setAuthToken(token) {
        this.authToken = token;
    }
    transformOptions(options) {
        if (this.authToken) {
            options.headers["authorization"] = `Bearer ${this.authToken}`;
        }
        return Promise.resolve(options);
    }
}
export class VcmpCommunicationUserClient extends AuthApiBase {
    constructor(baseUrl, http) {
        super();
        Object.defineProperty(this, "http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "jsonParseReviver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        this.http = http ? http : window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }
    /**
     * @param communicationUserIds (optional)
     * @return OK
     */
    getCommunicationUsers(communicationUserIds) {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/info?";
        if (communicationUserIds === null)
            throw new Error("The parameter 'communicationUserIds' cannot be null.");
        else if (communicationUserIds !== undefined)
            communicationUserIds && communicationUserIds.forEach(item => { url_ += "communicationUserIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetCommunicationUsers(_response);
        });
    }
    processGetCommunicationUsers(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(CommunicationUser.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @return OK
     */
    getOperator() {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/operator";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetOperator(_response);
        });
    }
    processGetOperator(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CommunicationUser.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param userId (optional)
     * @param userType (optional)
     * @return OK
     */
    getOrCreateCommunicationUser(userId, userType) {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/getorcreate?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "userType=" + encodeURIComponent("" + userType) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetOrCreateCommunicationUser(_response);
        });
    }
    processGetOrCreateCommunicationUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CommunicationUser.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    getSeller(body) {
        let url_ = this.baseUrl + "/api/vcmp/communicationuser/seller";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetSeller(_response);
        });
    }
    processGetSeller(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CommunicationUser.fromJS(resultData200);
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class VcmpConversationClient extends AuthApiBase {
    constructor(baseUrl, http) {
        super();
        Object.defineProperty(this, "http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "jsonParseReviver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        this.http = http ? http : window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    search(body) {
        let url_ = this.baseUrl + "/api/vcmp/conversation/search";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processSearch(_response);
        });
    }
    processSearch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SearchConversationResult.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param conversationId (optional)
     * @return OK
     */
    getById(conversationId) {
        let url_ = this.baseUrl + "/api/vcmp/conversation/getbyid?";
        if (conversationId === null)
            throw new Error("The parameter 'conversationId' cannot be null.");
        else if (conversationId !== undefined)
            url_ += "conversationId=" + encodeURIComponent("" + conversationId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetById(_response);
        });
    }
    processGetById(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Conversation.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param entityId (optional)
     * @param entityType (optional)
     * @return OK
     */
    getByEntity(entityId, entityType) {
        let url_ = this.baseUrl + "/api/vcmp/conversation/getbyentity?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (entityType === null)
            throw new Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetByEntity(_response);
        });
    }
    processGetByEntity(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Conversation.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    createConversation(body) {
        let url_ = this.baseUrl + "/api/vcmp/conversation/new";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processCreateConversation(_response);
        });
    }
    processCreateConversation(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Conversation.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    updateConversation(body) {
        let url_ = this.baseUrl + "/api/vcmp/conversation/update";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processUpdateConversation(_response);
        });
    }
    processUpdateConversation(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Conversation.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class VcmpMessageClient extends AuthApiBase {
    constructor(baseUrl, http) {
        super();
        Object.defineProperty(this, "http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "jsonParseReviver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        this.http = http ? http : window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    search(body) {
        let url_ = this.baseUrl + "/api/vcmp/message/search";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processSearch(_response);
        });
    }
    processSearch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SearchMessageResult.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param messageId (optional)
     * @return OK
     */
    getMessageById(messageId) {
        let url_ = this.baseUrl + "/api/vcmp/message/getbyid?";
        if (messageId === null)
            throw new Error("The parameter 'messageId' cannot be null.");
        else if (messageId !== undefined)
            url_ += "messageId=" + encodeURIComponent("" + messageId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetMessageById(_response);
        });
    }
    processGetMessageById(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Message.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param threadId (optional)
     * @return OK
     */
    getThread(threadId) {
        let url_ = this.baseUrl + "/api/vcmp/message/thread?";
        if (threadId === null)
            throw new Error("The parameter 'threadId' cannot be null.");
        else if (threadId !== undefined)
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetThread(_response);
        });
    }
    processGetThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Message.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    sendMessage(body) {
        let url_ = this.baseUrl + "/api/vcmp/message/new";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processSendMessage(_response);
        });
    }
    processSendMessage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    updateMessage(body) {
        let url_ = this.baseUrl + "/api/vcmp/message/update";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processUpdateMessage(_response);
        });
    }
    processUpdateMessage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    deleteMessage(body) {
        let url_ = this.baseUrl + "/api/vcmp/message";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processDeleteMessage(_response);
        });
    }
    processDeleteMessage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    markMessageAsRead(body) {
        let url_ = this.baseUrl + "/api/vcmp/message/markread";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processMarkMessageAsRead(_response);
        });
    }
    processMarkMessageAsRead(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    sendReaction(body) {
        let url_ = this.baseUrl + "/api/vcmp/message/sendreaction";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processSendReaction(_response);
        });
    }
    processSendReaction(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param body (optional)
     * @return OK
     */
    getUnreadMessageCount(body) {
        let url_ = this.baseUrl + "/api/vcmp/message/unreadcount";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response) => {
            return this.processGetUnreadMessageCount(_response);
        });
    }
    processGetUnreadMessageCount(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class CommunicationUser {
    constructor(data) {
        Object.defineProperty(this, "userName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "avatarUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.userType = _data["userType"];
            this.avatarUrl = _data["avatarUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationUser();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["userType"] = this.userType;
        data["avatarUrl"] = this.avatarUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class Conversation {
    constructor(data) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "iconUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastMessageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastMessageTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "users", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unreadMessagesCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.lastMessageId = _data["lastMessageId"];
            this.lastMessageTimestamp = _data["lastMessageTimestamp"] ? new Date(_data["lastMessageTimestamp"].toString()) : undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [];
                for (let item of _data["users"])
                    this.users.push(ConversationUser.fromJS(item));
            }
            this.unreadMessagesCount = _data["unreadMessagesCount"];
            this.lastMessage = _data["lastMessage"] ? Message.fromJS(_data["lastMessage"]) : undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Conversation();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["lastMessageId"] = this.lastMessageId;
        data["lastMessageTimestamp"] = this.lastMessageTimestamp ? this.lastMessageTimestamp.toISOString() : undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["unreadMessagesCount"] = this.unreadMessagesCount;
        data["lastMessage"] = this.lastMessage ? this.lastMessage.toJSON() : undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class ConversationUser {
    constructor(data) {
        Object.defineProperty(this, "conversationId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.conversationId = _data["conversationId"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new ConversationUser();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["conversationId"] = this.conversationId;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class CreateConversationCommand {
    constructor(data) {
        Object.defineProperty(this, "userIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "iconUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.userIds = [];
        }
    }
    init(_data) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [];
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConversationCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        return data;
    }
}
export class DeleteMessageCommand {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messageIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.messageIds = [];
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            if (Array.isArray(_data["messageIds"])) {
                this.messageIds = [];
                for (let item of _data["messageIds"])
                    this.messageIds.push(item);
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMessageCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        if (Array.isArray(this.messageIds)) {
            data["messageIds"] = [];
            for (let item of this.messageIds)
                data["messageIds"].push(item);
        }
        return data;
    }
}
export class GetSellerCommunicationUserQuery {
    constructor(data) {
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new GetSellerCommunicationUserQuery();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        return data;
    }
}
export class GetUnreadCountQuery {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recipientId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.recipientId = _data["recipientId"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnreadCountQuery();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["recipientId"] = this.recipientId;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        return data;
    }
}
export class MarkMessageAsReadCommand {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recipientId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "notRead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.messageId = _data["messageId"];
            this.recipientId = _data["recipientId"];
            this.notRead = _data["notRead"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MarkMessageAsReadCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["messageId"] = this.messageId;
        data["recipientId"] = this.recipientId;
        data["notRead"] = this.notRead;
        return data;
    }
}
export class Message {
    constructor(data) {
        Object.defineProperty(this, "senderId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "threadId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "conversationId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "attachments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recipients", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reactions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "answers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "conversation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "answersCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.senderId = _data["senderId"];
            this.content = _data["content"];
            this.threadId = _data["threadId"];
            this.conversationId = _data["conversationId"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [];
                for (let item of _data["attachments"])
                    this.attachments.push(MessageAttachment.fromJS(item));
            }
            if (Array.isArray(_data["recipients"])) {
                this.recipients = [];
                for (let item of _data["recipients"])
                    this.recipients.push(MessageRecipient.fromJS(item));
            }
            if (Array.isArray(_data["reactions"])) {
                this.reactions = [];
                for (let item of _data["reactions"])
                    this.reactions.push(MessageReaction.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [];
                for (let item of _data["answers"])
                    this.answers.push(Message.fromJS(item));
            }
            this.conversation = _data["conversation"] ? Conversation.fromJS(_data["conversation"]) : undefined;
            this.answersCount = _data["answersCount"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.sender = _data["sender"] ? CommunicationUser.fromJS(_data["sender"]) : undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["senderId"] = this.senderId;
        data["content"] = this.content;
        data["threadId"] = this.threadId;
        data["conversationId"] = this.conversationId;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.recipients)) {
            data["recipients"] = [];
            for (let item of this.recipients)
                data["recipients"].push(item.toJSON());
        }
        if (Array.isArray(this.reactions)) {
            data["reactions"] = [];
            for (let item of this.reactions)
                data["reactions"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["conversation"] = this.conversation ? this.conversation.toJSON() : undefined;
        data["answersCount"] = this.answersCount;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["sender"] = this.sender ? this.sender.toJSON() : undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class MessageAttachment {
    constructor(data) {
        Object.defineProperty(this, "messageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "attachmentUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fileType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fileSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.attachmentUrl = _data["attachmentUrl"];
            this.fileType = _data["fileType"];
            this.fileSize = _data["fileSize"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MessageAttachment();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["attachmentUrl"] = this.attachmentUrl;
        data["fileType"] = this.fileType;
        data["fileSize"] = this.fileSize;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class MessageReaction {
    constructor(data) {
        Object.defineProperty(this, "messageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.userId = _data["userId"];
            this.reaction = _data["reaction"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MessageReaction();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["userId"] = this.userId;
        data["reaction"] = this.reaction;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class MessageRecipient {
    constructor(data) {
        Object.defineProperty(this, "messageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recipientId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "readStatus", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "readTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "createdBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modifiedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.messageId = _data["messageId"];
            this.recipientId = _data["recipientId"];
            this.readStatus = _data["readStatus"];
            this.readTimestamp = _data["readTimestamp"] ? new Date(_data["readTimestamp"].toString()) : undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MessageRecipient();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["recipientId"] = this.recipientId;
        data["readStatus"] = this.readStatus;
        data["readTimestamp"] = this.readTimestamp ? this.readTimestamp.toISOString() : undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}
export class MessageShort {
    constructor(data) {
        Object.defineProperty(this, "senderId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recipientId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "conversationId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "replyTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.senderId = _data["senderId"];
            this.recipientId = _data["recipientId"];
            this.conversationId = _data["conversationId"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.content = _data["content"];
            this.replyTo = _data["replyTo"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MessageShort();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["senderId"] = this.senderId;
        data["recipientId"] = this.recipientId;
        data["conversationId"] = this.conversationId;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["content"] = this.content;
        data["replyTo"] = this.replyTo;
        return data;
    }
}
export class SearchConversationResult {
    constructor(data) {
        Object.defineProperty(this, "totalCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "results", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [];
                for (let item of _data["results"])
                    this.results.push(Conversation.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SearchConversationResult();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}
export class SearchConversationsQuery {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "responseGroup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "objectType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "objectTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "objectIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyword", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchPhrase", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "languageCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sort", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sortInfos", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "skip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "take", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [];
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [];
                for (let item of _data["objectTypes"])
                    this.objectTypes.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [];
                for (let item of _data["objectIds"])
                    this.objectIds.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                this.sortInfos = [];
                for (let item of _data["sortInfos"])
                    this.sortInfos.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SearchConversationsQuery();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}
export class SearchMessageResult {
    constructor(data) {
        Object.defineProperty(this, "totalCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "results", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [];
                for (let item of _data["results"])
                    this.results.push(Message.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SearchMessageResult();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}
export class SearchMessagesQuery {
    constructor(data) {
        Object.defineProperty(this, "entityId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entityType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "conversationId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "threadId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rootsOnly", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "responseGroup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "objectType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "objectTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "objectIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyword", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchPhrase", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "languageCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sort", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sortInfos", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "skip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "take", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.conversationId = _data["conversationId"];
            this.threadId = _data["threadId"];
            this.rootsOnly = _data["rootsOnly"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [];
                for (let item of _data["objectTypes"])
                    this.objectTypes.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [];
                for (let item of _data["objectIds"])
                    this.objectIds.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                this.sortInfos = [];
                for (let item of _data["sortInfos"])
                    this.sortInfos.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SearchMessagesQuery();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["conversationId"] = this.conversationId;
        data["threadId"] = this.threadId;
        data["rootsOnly"] = this.rootsOnly;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}
export class SendMessageCommand {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.message = new MessageShort();
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.message = _data["message"] ? MessageShort.fromJS(_data["message"]) : new MessageShort();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["message"] = this.message ? this.message.toJSON() : undefined;
        return data;
    }
}
export class SendReactionCommand {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reactorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.messageId = _data["messageId"];
            this.reactorId = _data["reactorId"];
            this.reaction = _data["reaction"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SendReactionCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["messageId"] = this.messageId;
        data["reactorId"] = this.reactorId;
        data["reaction"] = this.reaction;
        return data;
    }
}
export var SortDirection;
(function (SortDirection) {
    SortDirection["Ascending"] = "Ascending";
    SortDirection["Descending"] = "Descending";
})(SortDirection || (SortDirection = {}));
export class SortInfo {
    constructor(data) {
        Object.defineProperty(this, "sortColumn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sortDirection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}
export class UpdateConversationCommand {
    constructor(data) {
        Object.defineProperty(this, "conversation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.conversation = new Conversation();
        }
    }
    init(_data) {
        if (_data) {
            this.conversation = _data["conversation"] ? Conversation.fromJS(_data["conversation"]) : new Conversation();
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateConversationCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["conversation"] = this.conversation ? this.conversation.toJSON() : undefined;
        return data;
    }
}
export class UpdateMessageCommand {
    constructor(data) {
        Object.defineProperty(this, "sellerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sellerName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.messageId = _data["messageId"];
            this.content = _data["content"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageCommand();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["messageId"] = this.messageId;
        data["content"] = this.content;
        return data;
    }
}
export var SortInfoSortDirection;
(function (SortInfoSortDirection) {
    SortInfoSortDirection["Ascending"] = "Ascending";
    SortInfoSortDirection["Descending"] = "Descending";
})(SortInfoSortDirection || (SortInfoSortDirection = {}));
export class ApiException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "result", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isApiException", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isApiException(obj) {
        return obj.isApiException === true;
    }
}
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
/* eslint-disable */ 
//# sourceMappingURL=virtocommerce.marketplacecommunication.js.map